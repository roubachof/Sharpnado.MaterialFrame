//------------------------------------------------------------------------------
//
// https://github.com/mmin18/RealtimeBlurView
// Latest commit    82df352     on 24 May 2019
//
// Copyright 2016 Tu Yimin (http://github.com/mmin18)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//------------------------------------------------------------------------------
// Adapted to csharp and Xamarin.Forms by Jean-Marie Alfonsi
//------------------------------------------------------------------------------
// <auto-generated/>

using Android.App;
using Android.Content;
using Android.Graphics;
using Android.OS;
using Android.Runtime;
using Android.Views;

using Java.Lang;
using Color = Android.Graphics.Color;
using Exception = System.Exception;
using Math = System.Math;
using Paint = Android.Graphics.Paint;
using Rect = Android.Graphics.Rect;
using RectF = Android.Graphics.RectF;
using View = Android.Views.View;

namespace Sharpnado.MaterialFrame.Droid;

/**
 * A realtime blurring overlay (like iOS UIVisualEffectView). Just put it above
 * the view you want to blur and it doesn't have to be in the same ViewGroup
 * <ul>
 * <li>realtimeBlurRadius (10dp)</li>
 * <li>realtimeDownsampleFactor (4)</li>
 * <li>realtimeOverlayColor (#aaffffff)</li>
 * </ul>
 */
public class RealtimeBlurView : View
{
    private const bool LogDrawing = false;

    private static int _realtimeBlurViewInstanceCount;

    private float mDownsampleFactor; // default 4

    private int mOverlayColor; // default #aaffffff

    private float mBlurRadius; // default 10dp (0 < r <= 25)

    private float mCornerRadius; // default 0

    private readonly IBlurImpl mBlurImpl;

    private readonly string _formsId;

    private bool mDirty;

    private Bitmap mBitmapToBlur, mBlurredBitmap;

    private Canvas mBlurringCanvas;

    private bool mIsRendering;

    private Paint mPaint;

    private Rect mRectSrc = new Rect(), mRectDst = new Rect();

    // Async blur state
    private volatile bool _blurInFlight;
    private readonly object _blurLock = new object();
    private CancellationTokenSource _blurCts;

    // Double-buffered blurred outputs (back buffer and displayed buffer)
    private Bitmap mBlurredBitmapBack;
    private Bitmap mDisplayedBlurredBitmap;

    // Change detection to skip blur when background is static
    private int _lastContentHash;
    private const int ChangeDetectionSampleCount = 64; // Sample 64 pixels

    // mDecorView should be the root view of the activity (even if you are on a different window like a dialog)
    // private View mDecorView;

    private JniWeakReference<View> _weakDecorView;

    // If the view is on different root view (usually means we are on a PopupWindow),
    // we need to manually call invalidate() in onPreDraw(), otherwise we will not be able to see the changes
    private bool mDifferentRoot;

    private bool _isContainerShown;

    private bool _autoUpdate;

    private static int RENDERING_COUNT;

    private static int BLUR_IMPL;

    public RealtimeBlurView(Context context, string formsId)
        : base(context)
    {
        mBlurImpl = GetBlurImpl(); // provide your own by override getBlurImpl()
        mPaint = new Paint();

        _formsId = formsId;
        _isContainerShown = true;
        _autoUpdate = true;

        preDrawListener = new PreDrawListener(this);

        _blurCts = new CancellationTokenSource();

        _realtimeBlurViewInstanceCount++;
        InternalLogger.Debug("RealtimeBlurView", $"Constructor => Active instances: {_realtimeBlurViewInstanceCount}");
    }

    public RealtimeBlurView(IntPtr javaReference, JniHandleOwnership transfer)
        : base(javaReference, transfer)
    {
    }

    protected override void JavaFinalize()
    {
        base.JavaFinalize();

        _realtimeBlurViewInstanceCount--;
        InternalLogger.Debug("RealtimeBlurView", $"JavaFinalize() => Active instances: {_realtimeBlurViewInstanceCount}");
    }

    protected IBlurImpl GetBlurImpl()
    {
        // Use StackBlur for all Android versions:
        // - Works on all devices (no API level restrictions)
        // - No 16KB page issues (unlike RenderScript on Android 15+)
        // - Good performance for real-time blur (~15-25ms for 500x500)
        // - Simple and maintainable
        BLUR_IMPL = 2; // StackBlur
        return new AndroidStackBlur();
    }

    public void SetCornerRadius(float radius)
    {
        if (mCornerRadius != radius)
        {
            mCornerRadius = radius;
            mDirty = true;
            Invalidate();
        }
    }

    public void SetDownsampleFactor(float factor)
    {
        if (factor <= 0)
        {
            throw new ArgumentException("Downsample factor must be greater than 0.");
        }

        if (mDownsampleFactor != factor)
        {
            mDownsampleFactor = factor;
            mDirty = true; // may also change blur radius
            ReleaseBitmap();
            Invalidate();
        }
    }

    private void SubscribeToPreDraw(View decorView)
    {
        if (decorView.IsNullOrDisposed() || decorView.ViewTreeObserver.IsNullOrDisposed())
        {
            return;
        }

        decorView.ViewTreeObserver.AddOnPreDrawListener(preDrawListener);
    }

    private void UnsubscribeToPreDraw(View decorView)
    {
        if (decorView.IsNullOrDisposed() || decorView.ViewTreeObserver.IsNullOrDisposed())
        {
            return;
        }

        decorView.ViewTreeObserver.RemoveOnPreDrawListener(preDrawListener);
    }

    public void Destroy()
    {
        InternalLogger.Debug($"BlurView@{GetHashCode()}", () => "Destroy()");

        if (_weakDecorView != null && _weakDecorView.TryGetTarget(out var mDecorView))
        {
            UnsubscribeToPreDraw(mDecorView);
        }

        Release();
        _weakDecorView = null;
    }

    public void Release()
    {
        SetRootView(null);
        ReleaseBitmap();

        try
        {
            _blurCts?.Cancel();
        }
        catch {}
        finally
        {
            _blurCts?.Dispose();
            _blurCts = null;
        }

        mBlurImpl?.Release();
    }

    public void SetBlurRadius(float radius, bool invalidate = true)
    {
        if (mBlurRadius != radius)
        {
            mBlurRadius = radius;
            mDirty = true;
            if (invalidate)
            {
                Invalidate();
            }
        }
    }

    public void SetOverlayColor(int color, bool invalidate = true)
    {
        if (mOverlayColor != color)
        {
            mOverlayColor = color;
            if (invalidate)
            {
                Invalidate();
            }
        }
    }

    public void SetRootView(View rootView)
    {
        var mDecorView = GetRootView();
        if (mDecorView != rootView)
        {
            UnsubscribeToPreDraw(mDecorView);

            _weakDecorView = new JniWeakReference<View>(rootView);

            if (IsAttachedToWindow)
            {
                OnAttached(rootView);
            }
        }
    }

    private View GetRootView()
    {
        View mDecorView = null;
        _weakDecorView?.TryGetTarget(out mDecorView);
        return mDecorView;
    }

    private void OnAttached(View mDecorView)
    {
        if (mDecorView != null)
        {
            using var handler = new Handler();
            handler.PostDelayed(
                () =>
                {
                    SubscribeToPreDraw(mDecorView);
                    mDifferentRoot = mDecorView.RootView != RootView;
                    if (mDifferentRoot)
                    {
                        mDecorView.PostInvalidate();
                    }
                },
                AndroidMaterialFrameHandler.BlurProcessingDelayMilliseconds);
        }
        else
        {
            mDifferentRoot = false;
        }
    }

    protected override void OnVisibilityChanged(View changedView, [GeneratedEnum] ViewStates visibility)
    {
        base.OnVisibilityChanged(changedView, visibility);

        if (changedView.GetType().Name == "PageContainer")
        {
            _isContainerShown = visibility == ViewStates.Visible;
            SetAutoUpdate(_isContainerShown);
        }
    }

    private void SetAutoUpdate(bool autoUpdate)
    {
        if (autoUpdate)
        {
            EnableAutoUpdate();
            return;
        }

        DisableAutoUpdate();
    }

    private void EnableAutoUpdate()
    {
        if (_autoUpdate)
        {
            return;
        }

        InternalLogger.Debug($"BlurView@{GetHashCode()}", () => $"EnableAutoUpdate()");

        _autoUpdate = true;
        using var handler = new Handler();
        handler.PostDelayed(
            () =>
            {
                var mDecorView = GetRootView();
                if (mDecorView == null || !_autoUpdate)
                {
                    return;
                }

                SubscribeToPreDraw(mDecorView);
            },
            AndroidMaterialFrameHandler.BlurAutoUpdateDelayMilliseconds);
    }

    private void DisableAutoUpdate()
    {
        if (!_autoUpdate)
        {
            return;
        }

        InternalLogger.Debug($"BlurView@{GetHashCode()}", () => $"DisableAutoUpdate()");

        _autoUpdate = false;
        var mDecorView = GetRootView();
        if (mDecorView == null)
        {
            return;
        }

        UnsubscribeToPreDraw(mDecorView);
    }

    private void ReleaseBitmap()
    {
        if (!mBitmapToBlur.IsNullOrDisposed())
        {
            mBitmapToBlur.Recycle();
            mBitmapToBlur = null;
        }

        if (!mBlurredBitmap.IsNullOrDisposed())
        {
            mBlurredBitmap.Recycle();
            mBlurredBitmap = null;
        }

        if (!mBlurredBitmapBack.IsNullOrDisposed())
        {
            mBlurredBitmapBack.Recycle();
            mBlurredBitmapBack = null;
        }

        mDisplayedBlurredBitmap = null;
    }

    protected bool Prepare()
    {
        if (mBlurRadius == 0)
        {
            Release();
            return false;
        }

        float downsampleFactor = mDownsampleFactor;
        float radius = mBlurRadius / downsampleFactor;
        if (radius > 25)
        {
            downsampleFactor = downsampleFactor * radius / 25;
            radius = 25;
        }

        int width = Width;
        int height = Height;

        int scaledWidth = Math.Max(1, (int)(width / downsampleFactor));
        int scaledHeight = Math.Max(1, (int)(height / downsampleFactor));

        bool dirty = mDirty;

        if (mBlurringCanvas == null
            || mBlurredBitmap == null
            || mBlurredBitmap.Width != scaledWidth
            || mBlurredBitmap.Height != scaledHeight)
        {
            dirty = true;
            ReleaseBitmap();

            bool r = false;
            try
            {
                mBitmapToBlur = Bitmap.CreateBitmap(scaledWidth, scaledHeight, Bitmap.Config.Argb8888);
                if (mBitmapToBlur == null)
                {
                    return false;
                }

                mBlurringCanvas = new Canvas(mBitmapToBlur);

                InternalLogger.Debug($"BlurView@{GetHashCode()}", () => $"Prepare() => Bitmap.CreateBitmap()");
                mBlurredBitmap = Bitmap.CreateBitmap(scaledWidth, scaledHeight, Bitmap.Config.Argb8888);
                if (mBlurredBitmap == null)
                {
                    return false;
                }

                r = true;
            }
            catch (OutOfMemoryError e)
            {
                // Bitmap.createBitmap() may cause OOM error
                // Simply ignore and fallback
                InternalLogger.Warn($"OutOfMemoryError occured while trying to render the blur view: {e.Message}");
            }
            finally
            {
                if (!r)
                {
                    Release();
                }
            }

            if (!r)
            {
                return false;
            }
        }

        if (dirty)
        {
            InternalLogger.Debug($"BlurView@{GetHashCode()}", () => $"Prepare() => dirty: mBlurImpl.Prepare()");
            if (mBlurImpl.Prepare(Context, mBitmapToBlur, radius))
            {
                mDirty = false;
            }
            else
            {
                return false;
            }
        }

        // Ensure back buffer exists and matches size
        if (mBlurredBitmapBack == null
            || mBlurredBitmapBack.Width != scaledWidth
            || mBlurredBitmapBack.Height != scaledHeight)
        {
            if (!mBlurredBitmapBack.IsNullOrDisposed())
            {
                mBlurredBitmapBack.Recycle();
            }
            mBlurredBitmapBack = Bitmap.CreateBitmap(scaledWidth, scaledHeight, Bitmap.Config.Argb8888);
        }

        return true;
    }

    protected void Blur(Bitmap bitmapToBlur, Bitmap blurredBitmap)
    {
        mBlurImpl.Blur(bitmapToBlur, blurredBitmap);
    }

    private void ScheduleAsyncBlur()
    {
        // Skip if blur already in flight or no data
        if (_blurInFlight || mBitmapToBlur == null || Width == 0 || Height == 0)
        {
            return;
        }

        // Change detection: skip blur if content hasn't changed
        int currentHash = ComputeContentHash(mBitmapToBlur);
        if (currentHash == _lastContentHash && mDisplayedBlurredBitmap != null)
        {
            InternalLogger.DebugIf(LogDrawing, $"BlurView@{GetHashCode()}", () => $"ScheduleAsyncBlur => skipping, content unchanged (hash: {currentHash})");
            return;
        }
        _lastContentHash = currentHash;

        lock (_blurLock)
        {
            if (_blurInFlight)
            {
                return;
            }
            _blurInFlight = true;
        }

        // Make a copy of the captured bitmap for background processing
        Bitmap inputCopy = null;
        try
        {
            inputCopy = Bitmap.CreateBitmap(mBitmapToBlur);
        }
        catch (OutOfMemoryError e)
        {
            InternalLogger.Warn($"BlurView@{GetHashCode()}", () => $"ScheduleAsyncBlur => OOM on CreateBitmap copy: {e.Message}");
            lock (_blurLock) { _blurInFlight = false; }
            return;
        }

        var token = _blurCts?.Token ?? CancellationToken.None;

        Task.Run(() =>
        {
            try
            {
                if (token.IsCancellationRequested)
                {
                    return;
                }

                // Ensure back buffer exists and matches input size
                if (mBlurredBitmapBack == null
                    || mBlurredBitmapBack.Width != inputCopy.Width
                    || mBlurredBitmapBack.Height != inputCopy.Height)
                {
                    if (!mBlurredBitmapBack.IsNullOrDisposed())
                    {
                        mBlurredBitmapBack.Recycle();
                    }
                    mBlurredBitmapBack = Bitmap.CreateBitmap(inputCopy.Width, inputCopy.Height, Bitmap.Config.Argb8888);
                }

                // Perform blur on background thread
                InternalLogger.DebugIf(LogDrawing, $"BlurView@{GetHashCode()}", () => $"ScheduleAsyncBlur => running blur on background thread");
                mBlurImpl.Blur(inputCopy, mBlurredBitmapBack);
            }
            catch (Exception ex)
            {
                InternalLogger.Error($"BlurView@{GetHashCode()}", () => $"ScheduleAsyncBlur => background blur failed: {ex.Message}");
            }
            finally
            {
                // Dispose the copy to free memory
                if (!inputCopy.IsNullOrDisposed())
                {
                    inputCopy.Recycle();
                    inputCopy = null;
                }

                // Swap displayed buffer on UI thread
                Post(() =>
                {
                    try
                    {
                        // Atomically swap back buffer into display
                        mDisplayedBlurredBitmap = mBlurredBitmapBack;
                        Invalidate();
                        InternalLogger.DebugIf(LogDrawing, $"BlurView@{GetHashCode()}", () => $"ScheduleAsyncBlur => swapped and invalidated");
                    }
                    finally
                    {
                        lock (_blurLock) { _blurInFlight = false; }
                    }
                });
            }
        }, token);
    }

    /// <summary>
    /// Computes a fast hash of the bitmap content by sampling pixels.
    /// Used for change detection to skip blur when content is static.
    /// </summary>
    private int ComputeContentHash(Bitmap bitmap)
    {
        if (bitmap == null || bitmap.Width == 0 || bitmap.Height == 0)
        {
            return 0;
        }

        int width = bitmap.Width;
        int height = bitmap.Height;
        int totalPixels = width * height;

        // Sample pixels in a grid pattern
        int sampleCount = Math.Min(ChangeDetectionSampleCount, totalPixels);
        int step = Math.Max(1, totalPixels / sampleCount);

        try
        {
            // Use GetPixels for fast access (bulk read)
            int[] pixels = new int[totalPixels];
            bitmap.GetPixels(pixels, 0, width, 0, 0, width, height);

            int hash = 17;
            for (int i = 0; i < totalPixels; i += step)
            {
                hash = hash * 31 + pixels[i];
            }

            return hash;
        }
        catch
        {
            // If fails, return 0 to force blur
            return 0;
        }
    }

    private readonly PreDrawListener preDrawListener;

    private class PreDrawListener : Java.Lang.Object, ViewTreeObserver.IOnPreDrawListener
    {
        private readonly JniWeakReference<RealtimeBlurView> _weakBlurView;

        public PreDrawListener(RealtimeBlurView blurView)
        {
            _weakBlurView = new JniWeakReference<RealtimeBlurView>(blurView);
        }

        public PreDrawListener(IntPtr handle, JniHandleOwnership transfer)
            : base(handle, transfer)
        {
        }

        public bool OnPreDraw()
        {
            if (!_weakBlurView.TryGetTarget(out var blurView))
            {
                return false;
            }

            if (!blurView._isContainerShown)
            {
                return false;
            }

            var mDecorView = blurView.GetRootView();

            InternalLogger.DebugIf(LogDrawing, $"BlurView@{blurView.GetHashCode()}", () => $"OnPreDraw()");

            int[] locations = new int[2];
            Bitmap oldBmp = blurView.mBlurredBitmap;
            View decor = mDecorView;
            if (!decor.IsNullOrDisposed() && blurView.IsShown && blurView.Prepare())
            {
                InternalLogger.DebugIf(LogDrawing, $"BlurView@{blurView.GetHashCode()}", () => $"OnPreDraw(formsId: {blurView._formsId}) => calling draw on decor");
                bool redrawBitmap = blurView.mBlurredBitmap != oldBmp;
                oldBmp = null;
                decor.GetLocationOnScreen(locations);
                int x = -locations[0];
                int y = -locations[1];

                blurView.GetLocationOnScreen(locations);
                x += locations[0];
                y += locations[1];

                // just erase transparent
                blurView.mBitmapToBlur.EraseColor(blurView.mOverlayColor & 0xffffff);

                int rc = blurView.mBlurringCanvas.Save();
                blurView.mIsRendering = true;
                RENDERING_COUNT++;
                try
                {
                    blurView.mBlurringCanvas.Scale(
                        1f * blurView.mBitmapToBlur.Width / blurView.Width,
                        1f * blurView.mBitmapToBlur.Height / blurView.Height);
                    blurView.mBlurringCanvas.Translate(-x, -y);
                    if (decor.Background != null)
                    {
                        decor.Background.Draw(blurView.mBlurringCanvas);
                    }

                    decor.Draw(blurView.mBlurringCanvas);
                }
                catch (StopException)
                {
                    InternalLogger.DebugIf(LogDrawing, $"BlurView@{blurView.GetHashCode()}", () => $"OnPreDraw(formsId: {blurView._formsId}) => in catch StopException");
                }
                catch (Exception)
                {
                    InternalLogger.Error($"BlurView@{blurView.GetHashCode()}", () => $"OnPreDraw(formsId: {blurView._formsId}) => in catch global exception");
                }
                finally
                {
                    blurView.mIsRendering = false;
                    RENDERING_COUNT--;
                    blurView.mBlurringCanvas.RestoreToCount(rc);
                }

                InternalLogger.DebugIf(LogDrawing, $"BlurView@{blurView.GetHashCode()}", () => $"OnPreDraw(formsId: {blurView._formsId}) => scheduling async blur");
                blurView.ScheduleAsyncBlur();

                if (redrawBitmap || blurView.mDifferentRoot)
                {
                    InternalLogger.DebugIf(
                        LogDrawing,
                        $"BlurView@{blurView.GetHashCode()}",
                        () => $"OnPreDraw(formsId: {blurView._formsId}, redrawBitmap: {redrawBitmap}, differentRoot: {blurView.mDifferentRoot}) => blurView.Invalidate()");
                    blurView.Invalidate();
                }
            }

            return true;
        }
    }

    protected View GetActivityDecorView()
    {
        Context ctx = Context;
        for (int i = 0; i < 4 && ctx != null && !(ctx is Activity) && ctx is ContextWrapper; i++)
        {
            ctx = ((ContextWrapper)ctx).BaseContext;
        }

        if (ctx is Activity)
        {
            return ((Activity)ctx).Window.DecorView;
        }
        else
        {
            return null;
        }
    }

    protected override void OnAttachedToWindow()
    {
        InternalLogger.Debug($"BlurView@{GetHashCode()}", () => $"OnAttachedToWindow()");
        base.OnAttachedToWindow();

        var mDecorView = GetRootView();
        if (mDecorView == null)
        {
            SetRootView(GetActivityDecorView());
        }
        else
        {
            OnAttached(mDecorView);
        }
    }

    protected override void OnDetachedFromWindow()
    {
        var mDecorView = GetRootView();
        if (mDecorView != null)
        {
            UnsubscribeToPreDraw(mDecorView);
        }

        InternalLogger.Debug($"BlurView@{GetHashCode()}", () => $"OnDetachedFromWindow()");
        Release();
        base.OnDetachedFromWindow();
    }

    public override void Draw(Canvas canvas)
    {
        if (mIsRendering)
        {
            InternalLogger.DebugIf(LogDrawing, $"BlurView@{GetHashCode()}", () => $"Draw() => throwing stop exception");

            // Quit here, don't draw views above me
            if (AndroidMaterialFrameHandler.ThrowStopExceptionOnDraw)
            {
                throw new StopException();
            }

            return;
        }

        if (RENDERING_COUNT > 0)
        {
            InternalLogger.DebugIf(LogDrawing, $"BlurView@{GetHashCode()}", () => $"Draw() => Doesn't support blurview overlap on another blurview");

            // Doesn't support blurview overlap on another blurview
        }
        else
        {
            InternalLogger.DebugIf(LogDrawing, $"BlurView@{GetHashCode()}", () => $"Draw() => calling base draw");
            base.Draw(canvas);
        }
    }

    protected override void OnDraw(Canvas canvas)
    {
        base.OnDraw(canvas);

        InternalLogger.Debug($"BlurView@{GetHashCode()}", () => $"OnDraw(formsId: {_formsId})");
        DrawRoundedBlurredBitmap(canvas, mDisplayedBlurredBitmap, mOverlayColor);
    }

    /**
     * Custom draw the blurred bitmap and color to define your own shape
     *
     * @param canvas
     * @param blurredBitmap
     * @param overlayColor
     */
    protected void DrawBlurredBitmap(Canvas canvas, Bitmap blurredBitmap, int overlayColor)
    {
        if (blurredBitmap != null)
        {
            mRectSrc.Right = blurredBitmap.Width;
            mRectSrc.Bottom = blurredBitmap.Height;
            mRectDst.Right = Width;
            mRectDst.Bottom = Height;
            canvas.DrawBitmap(blurredBitmap, mRectSrc, mRectDst, null);
        }

        mPaint.Color = new Color(overlayColor);
        canvas.DrawRect(mRectDst, mPaint);
    }

    private void DrawRoundedBlurredBitmap(Canvas canvas, Bitmap blurredBitmap, int overlayColor) {
        if (blurredBitmap != null)
        {
            InternalLogger.DebugIf(
                LogDrawing,
                $"BlurView@{GetHashCode()}",
                () => $"DrawRoundedBlurredBitmap( mCornerRadius: {mCornerRadius}, mOverlayColor: {mOverlayColor} )");

            var mRectF = new RectF { Right = Width, Bottom = Height };

            mPaint.Reset();
            mPaint.AntiAlias = true;
            BitmapShader shader = new BitmapShader(blurredBitmap, Shader.TileMode.Clamp, Shader.TileMode.Clamp);
            Matrix matrix = new Matrix();
            matrix.PostScale(mRectF.Width() / blurredBitmap.Width, mRectF.Height() / blurredBitmap.Height);
            shader.SetLocalMatrix(matrix);
            mPaint.SetShader(shader);
            canvas.DrawRoundRect(mRectF, mCornerRadius, mCornerRadius, mPaint);

            mPaint.Reset();
            mPaint.AntiAlias = true;
            mPaint.Color = new Color(overlayColor);
            canvas.DrawRoundRect(mRectF, mCornerRadius, mCornerRadius, mPaint);
        }
    }

    private class StopException : Exception;
}
